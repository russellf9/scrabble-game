{"version":3,"sources":["reducers.ts","constants.ts","context.tsx","components/drag-and-drop/movable-item/MovableItem.tsx","components/tile/TileComponent.tsx","components/tile-rack/TileRackComponent.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Types","ITEM_TYPES","TILES_NAMES","INITIAL","SELECTION","allTiles","letter","score","count","uniqueId","Date","now","getId","index","originalTiles","map","obj","id","name","currentParent","originalChosenTiles","moveItems","action","state","payload","dragIndex","hoverIndex","arrayToMutate","itemToMove","splice","tilesReducer","type","MoveTile","currentParentIsSelection","Initial","Selection","ChangeParent","newParent","arrayToRemoveItemFrom","arrayToAddItemTo","push","changeParent","initialState","tiles","AppContext","createContext","dispatch","mainReducer","AppProvider","children","useReducer","Provider","value","MovableItem","changeItemParent","moveItemHandler","ref","useRef","useDrop","accept","hover","item","monitor","current","console","log","hoverBoundingRect","getBoundingClientRect","hoverMiddleY","bottom","top","clientOffset","getClientOffset","hoverClientY","y","drop","useDrag","end","dropResult","getDropResult","collect","isDragging","opacity","drag","className","style","TileComponent","TileRackComponent","tileRackType","useContext","changeItemParentHandler","currentItem","tileType","isOver","canDrop","display","JSON","stringify","App","DndProvider","backend","HTML5Backend","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f4233f07.chunk.js","sourcesContent":["import { Key } from \"react\";\nimport { TileItemType } from \"./interfaces\";\n\ntype ActionMap<M extends { [index: string]: any }> = {\n  [key in keyof M]: M[Key] extends undefined\n    ? {\n        type: Key;\n      }\n    : {\n        type: Key;\n        payload: M[Key];\n      };\n};\n\nexport enum Types {\n  MoveTile = \"MOVE_TILE\", // for moveItemHandler\n  ChangeParent = \"CHANGE_PARENT\", // for changeItemParentHandler\n}\n\ntype TilePayload = {\n  [Types.MoveTile]: {\n    dragIndex: number;\n    hoverIndex: number;\n    currentParent: string;\n  };\n  [Types.ChangeParent]: {\n    newParent: string;\n    currentParent: string;\n    name: string;\n  };\n};\n\ntype DropItemPayload = {\n  dragIndex: number;\n  hoverIndex: number;\n  currentParent: string;\n};\n\ntype ChangeParentPayLoad = {\n  currentParent: string;\n  index: number;\n  name: string;\n  newParent: string;\n};\n\nexport type TileActions = ActionMap<TilePayload>[keyof ActionMap<TilePayload>];\n\n// TODO I wasn't able to type the `state` here\nconst moveItems = (action: TileActions, state: any) => {\n  const payload: DropItemPayload = action.payload as DropItemPayload;\n  const { currentParent, dragIndex, hoverIndex } = payload;\n  let arrayToMutate = state[currentParent];\n  const itemToMove: TileItemType = arrayToMutate[dragIndex];\n\n  arrayToMutate.splice(dragIndex, 1);\n  arrayToMutate.splice(hoverIndex, 0, itemToMove);\n\n  return arrayToMutate;\n};\n\nconst changeParent = (action: TileActions, state: any) => {\n  const payload: ChangeParentPayLoad = action.payload as ChangeParentPayLoad;\n\n  const { currentParent, index, newParent } = payload;\n\n  let arrayToRemoveItemFrom = state[currentParent];\n\n  const itemToMove: TileItemType = arrayToRemoveItemFrom[index];\n\n  arrayToRemoveItemFrom.splice(index, 1);\n\n  let arrayToAddItemTo = state[newParent];\n  arrayToAddItemTo.push(itemToMove); // TODO work out correct index later...\n\n  // there must be a btter way!\n  const currentParentIsInitial = currentParent === \"Initial\";\n  const currentParentIsSelection = currentParent === \"Selection\";\n\n  return {\n    Initial: currentParentIsInitial ? arrayToRemoveItemFrom : arrayToAddItemTo,\n    Selection: currentParentIsSelection\n      ? arrayToRemoveItemFrom\n      : arrayToAddItemTo,\n  };\n};\n\nexport const tilesReducer = (\n  //state: TileItemType[], TODO work out types...\n  state: any,\n  action: TileActions\n): any => {\n  // TileItemType[] => {\n  switch (action.type) {\n    case Types.MoveTile:\n      const payload: DropItemPayload = action.payload as DropItemPayload;\n      //console.log(payload);\n      const { currentParent } = payload;\n      //\n      //console.log(`is ${currentParent === \"Initial\"}`);\n      const currentParentIsInitial = currentParent === \"Initial\";\n      const currentParentIsSelection = currentParent === \"Selection\";\n      return {\n        Initial: currentParentIsInitial\n          ? moveItems(action, state)\n          : [...state.Initial],\n        Selection: currentParentIsSelection\n          ? moveItems(action, state)\n          : [...state.Selection],\n      };\n    case Types.ChangeParent:\n      return changeParent(action, state);\n\n    default:\n      return [...state];\n  }\n};\n","import { Tile, TileItemType } from \"./interfaces\";\n\nexport const ITEM_TYPES = {\n  DRAGGABLE_ITEM: \"draggable_item\",\n};\n\nexport const TILES_NAMES = {\n  INITIAL: \"Initial\",\n  SELECTION: \"Selection\",\n};\n\nconst { INITIAL, SELECTION } = TILES_NAMES;\n\nconst allTiles: Tile[] = [\n  { letter: \"e\", score: 1, count: 12 },\n  { letter: \"a\", score: 1, count: 9 },\n  { letter: \"i\", score: 1, count: 9 },\n  { letter: \"o\", score: 1, count: 8 },\n  { letter: \"n\", score: 1, count: 6 },\n  { letter: \"r\", score: 1, count: 6 },\n  { letter: \"t\", score: 1, count: 6 },\n  { letter: \"l\", score: 1, count: 4 },\n  { letter: \"s\", score: 1, count: 4 },\n  { letter: \"u\", score: 1, count: 4 },\n\n  { letter: \"d\", score: 2, count: 4 },\n  { letter: \"g\", score: 2, count: 3 },\n\n  { letter: \"b\", score: 3, count: 2 },\n  { letter: \"c\", score: 3, count: 2 },\n  { letter: \"m\", score: 3, count: 2 },\n  { letter: \"p\", score: 3, count: 2 },\n\n  { letter: \"f\", score: 4, count: 2 },\n  { letter: \"h\", score: 4, count: 2 },\n  { letter: \"v\", score: 4, count: 2 },\n  { letter: \"w\", score: 4, count: 2 },\n  { letter: \"y\", score: 4, count: 2 },\n\n  { letter: \"k\", score: 5, count: 1 },\n\n  { letter: \"j\", score: 8, count: 1 },\n  { letter: \"x\", score: 8, count: 1 },\n\n  { letter: \"q\", score: 10, count: 1 },\n  { letter: \"z\", score: 10, count: 1 },\n];\nconst initialLetters: Tile[] = [\n  allTiles[0],\n  allTiles[25],\n  allTiles[3],\n  allTiles[22],\n  allTiles[7],\n];\n\nconst uniqueId = () => Date.now();\n\nconst getId = (index: number) => uniqueId() + index;\n\n// TODO keep here for the time being\nexport const originalTiles: TileItemType[] = initialLetters.map(\n  (obj: Tile, index: number) => {\n    return {\n      ...obj,\n      id: getId(index),\n      name: `${index}-${obj.letter}`,\n      currentParent: INITIAL,\n    };\n  }\n);\n\n// using this list so I can populate the original Collection fo `chosenTiles`\nconst originalChosenLetters: Tile[] = [allTiles[3], allTiles[8]];\n\nexport const originalChosenTiles: TileItemType[] = originalChosenLetters.map(\n  (obj, index) => {\n    return {\n      ...obj,\n      id: uniqueId() + index,\n      name: `${index}-${obj.letter}`,\n      currentParent: SELECTION,\n    };\n  }\n);\n\n// utility function to test the values in the model\nexport const displayItems = (items: any) => {\n  items.forEach((item: any) => {\n    console.log(\"item \", item);\n  });\n};\n","import React, { createContext, useReducer } from \"react\";\nimport { originalChosenTiles, originalTiles } from \"./constants\";\nimport { TileItemType } from \"./interfaces\";\nimport { TileActions, tilesReducer } from \"./reducers\";\n\nexport type InitialStateType = {\n  tiles: {\n    Initial: TileItemType[];\n    Selection: TileItemType[];\n  };\n};\n\nconst initialState = {\n  tiles: {\n    Initial: originalTiles,\n    Selection: originalChosenTiles,\n  },\n};\n//\nconst AppContext = createContext<{\n  state: InitialStateType;\n  dispatch: React.Dispatch<TileActions>;\n}>({\n  state: initialState,\n  dispatch: () => null,\n});\n\nconst mainReducer = ({ tiles }: InitialStateType, action: TileActions) => ({\n  tiles: tilesReducer(tiles, action),\n});\n\nconst AppProvider: React.FC = ({ children }) => {\n  const [state, dispatch] = useReducer(mainReducer, initialState);\n\n  return (\n    <AppContext.Provider value={{ state, dispatch }}>\n      {children}\n    </AppContext.Provider>\n  );\n};\nexport { AppProvider, AppContext };\n","import { useRef } from \"react\";\nimport { useDrag, useDrop } from \"react-dnd\";\nimport { ItemType } from \"../../../interfaces\";\nimport { ITEM_TYPES } from \"../../../constants\";\n\nexport interface MovavbleItemProps {\n  name: string;\n  index: number;\n  currentParent: string;\n  children: JSX.Element;\n}\n\nexport interface MovableItemDispatchProps {\n  changeItemParent: (currentItem: ItemType, newParent: string) => void;\n  moveItemHandler: (\n    dragIndex: number,\n    hoverIndex: number,\n    currentParent: string\n  ) => void;\n}\n\ntype Props = MovavbleItemProps & MovableItemDispatchProps;\n\nexport const MovableItem = ({\n  name,\n  index,\n  currentParent,\n  children,\n  changeItemParent,\n  moveItemHandler,\n}: Props): JSX.Element => {\n  const ref = useRef(null);\n\n  const [, drop] = useDrop({\n    accept: ITEM_TYPES.DRAGGABLE_ITEM,\n    hover(item: any, monitor) {\n      if (!ref.current) {\n        return;\n      }\n\n      const dragIndex = item.index;\n      const hoverIndex = index;\n\n      // Don't replace items with themselves\n      if (dragIndex === hoverIndex) {\n        return;\n      }\n\n      const current = ref.current;\n\n      console.log(`current: ${current}`);\n      if (!current) {\n        return;\n      }\n\n      const element = current as Element;\n      const hoverBoundingRect = element.getBoundingClientRect();\n      // Get vertical middle\n      const hoverMiddleY =\n        (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;\n      // Determine mouse position\n      const clientOffset = monitor.getClientOffset();\n      // Get pixels to the top\n\n      const offsetY = clientOffset ? clientOffset.y : 0;\n      const hoverClientY = offsetY - hoverBoundingRect.top;\n      // Only perform the move when the mouse has crossed half of the items height\n      // When dragging downwards, only move when the cursor is below 50%\n      // When dragging upwards, only move when the cursor is above 50%\n      // Dragging downwards\n      if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {\n        return;\n      }\n      // Dragging upwards\n      if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {\n        return;\n      }\n      // Time to actually perform the action\n      //\n      //console.log(\"should be calling moveItemHandler\");\n      moveItemHandler(dragIndex, hoverIndex, currentParent);\n    },\n  });\n\n  const [{ isDragging }, drag] = useDrag({\n    item: { index, name, currentParent, type: ITEM_TYPES.DRAGGABLE_ITEM },\n    end: (item, monitor) => {\n      const dropResult = monitor.getDropResult();\n\n      if (item && dropResult && dropResult.name) {\n        const newParent = dropResult.name;\n        changeItemParent(item, newParent);\n      }\n    },\n    collect: (monitor) => ({\n      isDragging: monitor.isDragging(),\n    }),\n  });\n\n  const opacity = isDragging ? 0.4 : 1;\n\n  drag(drop(ref));\n\n  return (\n    <div ref={ref} className=\"movable-item\" style={{ opacity }}>\n      {children}\n    </div>\n  );\n};\n","import { ReactElement } from \"react\";\nimport { Tile } from \"../../interfaces\";\n\ntype Props = Tile;\n\nexport const TileComponent = ({ letter, score }: Props): ReactElement<Tile> => {\n  return (\n    <div className=\"center-box tile\">\n      <h1>{letter}</h1>\n      <p className=\"score\">{score}</p>\n    </div>\n  );\n};\n","import { useContext } from \"react\";\nimport { DropTargetMonitor, useDrop } from \"react-dnd\";\nimport { AppContext } from \"../../context\";\nimport { MovableItem } from \"../../components/drag-and-drop/movable-item/MovableItem\";\nimport { TileComponent } from \"../../components/tile/TileComponent\";\nimport { ITEM_TYPES } from \"../../constants\";\nimport { ItemType, TileItemType } from \"../../interfaces\";\nimport { Types } from \"../../reducers\";\n\ntype TileRackType = \"Initial\" | \"Selection\";\n\nexport interface TileRackProps {\n  tileRackType: TileRackType | string;\n  className: string;\n}\n\ntype Props = TileRackProps;\n\nexport const TileRackComponent = ({\n  tileRackType,\n  className,\n}: Props): JSX.Element => {\n  const { state, dispatch } = useContext(AppContext);\n\n  const changeItemParentHandler = (\n    currentItem: ItemType,\n    newParent: string\n  ): void => {\n    dispatch({\n      type: Types.ChangeParent,\n      payload: {\n        newParent,\n        currentParent: currentItem.currentParent,\n        name: currentItem.name,\n        index: currentItem.index,\n      },\n    });\n  };\n  const moveItemHandler = (\n    dragIndex: number,\n    hoverIndex: number,\n    currentParent: string\n  ): void => {\n    dispatch({\n      type: Types.MoveTile,\n      payload: {\n        dragIndex,\n        hoverIndex,\n        currentParent,\n      },\n    });\n  };\n\n  const renderTiles = (item: TileItemType, index: number): JSX.Element => (\n    <MovableItem\n      changeItemParent={changeItemParentHandler}\n      currentParent={item.currentParent}\n      index={index}\n      key={item.id}\n      moveItemHandler={moveItemHandler}\n      name={`${item ? item.name : \"not-known\"}`}\n    >\n      <TileComponent letter={item.letter} score={item.score} />\n    </MovableItem>\n  );\n\n  const tileType = tileRackType === \"Initial\" ? \"Initial\" : \"Selection\";\n  const tiles = state.tiles[tileType].map(renderTiles);\n\n  const [, drop] = useDrop({\n    accept: ITEM_TYPES.DRAGGABLE_ITEM,\n    drop: () => ({ name: tileRackType }),\n    collect: (monitor: DropTargetMonitor) => ({\n      isOver: monitor.isOver(),\n      canDrop: monitor.canDrop(),\n    }),\n    canDrop: (item: any) => {\n      return item.currentParent !== tileRackType;\n    },\n  });\n  return (\n    <>\n      <div ref={drop} className={className}>\n        {tiles}\n      </div>\n      <p style={{ display: \"none\" }}>state: {JSON.stringify(state.tiles)}</p>\n    </>\n  );\n};\n","import { DndProvider } from \"react-dnd\";\nimport { HTML5Backend } from \"react-dnd-html5-backend\";\nimport \"./App.css\";\nimport { AppProvider } from \"./context\";\nimport { TILES_NAMES } from \"./constants\";\nimport { TileRackComponent } from \"./components/tile-rack/TileRackComponent\";\n\nconst App = (): JSX.Element => {\n  const { INITIAL, SELECTION } = TILES_NAMES;\n\n  return (\n    <div className=\"App\">\n      <div className=\"container\">\n        <AppProvider>\n          <DndProvider backend={HTML5Backend}>\n            <TileRackComponent\n              tileRackType={INITIAL}\n              className=\"tiles-container initial\"\n            />\n            <TileRackComponent\n              tileRackType={SELECTION}\n              className=\"tiles-container selection\"\n            />\n          </DndProvider>\n        </AppProvider>\n      </div>\n    </div>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}